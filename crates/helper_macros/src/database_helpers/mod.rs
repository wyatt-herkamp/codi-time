use heck::ToUpperCamelCase;
use proc_macro2::{Span, TokenStream};
use quote::{quote, ToTokens};
use syn::{parse::Parse, Data, DeriveInput, Fields, Result};

mod keywords {
    syn::custom_keyword!(id);
    syn::custom_keyword!(created);
    syn::custom_keyword!(name);
}
#[allow(unused)]
enum ColumnName {
    Id(keywords::id),
    Created(keywords::created),
    Name(keywords::name),
}
impl Parse for ColumnName {
    fn parse(input: syn::parse::ParseStream) -> Result<Self> {
        let lookahead = input.lookahead1();
        if lookahead.peek(keywords::id) {
            Ok(Self::Id(input.parse()?))
        } else if lookahead.peek(keywords::created) {
            Ok(Self::Created(input.parse()?))
        } else if lookahead.peek(keywords::name) {
            Ok(Self::Name(input.parse()?))
        } else {
            Err(lookahead.error())
        }
    }
}
pub struct Columns {
    pub id: syn::Ident,
    pub created: syn::Ident,
    pub name: Option<syn::Ident>,
}

impl Columns {
    pub fn new(fields: &syn::FieldsNamed) -> Result<Self> {
        let mut id = None;
        let mut created = None;
        let mut name = None;
        for field in fields.named.iter() {
            let attr = field
                .attrs
                .iter()
                .find(|v| v.path().is_ident("column"))
                .map(|v| v.parse_args::<ColumnName>())
                .transpose()?;
            let Some(attr) = attr else {
                continue;
            };
            let field_name = ident_to_upper_camel_case(field.ident.as_ref().unwrap());
            match attr {
                ColumnName::Id(_) => {
                    id = Some(field_name);
                }
                ColumnName::Created(_) => {
                    created = Some(field_name);
                }
                ColumnName::Name(_) => {
                    name = Some(field_name);
                }
            }
        }

        let id: proc_macro2::Ident =
            id.ok_or_else(|| syn::Error::new(Span::call_site(), "id column not found"))?;
        let created = created
            .ok_or_else(|| syn::Error::new(Span::call_site(), "created column not found"))?;
        Ok(Self { id, created, name })
    }
    fn has_name_impl(&self) -> TokenStream {
        let Some(name) = &self.name else {
            return TokenStream::default();
        };

        quote! {
            #[automatically_derived]
            impl HasNameColumn for Entity{
                const NAME_COLUMN: Self::Column = Self::Column::#name;
            }
        }
    }
}

impl ToTokens for Columns {
    fn to_tokens(&self, tokens: &mut TokenStream) {
        let id = &self.id;
        let created = &self.created;
        let has_name_impl = self.has_name_impl();
        tokens.extend(quote! {
            #[automatically_derived]
            impl BasicTableTrait for Entity{
                const ID_COLUMN: Self::Column = Self::Column::#id;
                const CREATED_COLUMN: Self::Column = Self::Column::#created;
            }
            #has_name_impl
        });
    }
}

pub fn expand(input: DeriveInput) -> Result<TokenStream> {
    if input.ident.to_string() != "Model" {
        return Err(syn::Error::new(
            Span::call_site(),
            "database_helpers can only be derived on the Model struct as it uses everything generated by sea_orm::derive::DeriveEntityModel",
        ));
    }
    let Data::Struct(struct_data) = input.data else {
        return Err(syn::Error::new(
            Span::call_site(),
            "database_helpers can only be used on structs",
        ));
    };
    let Fields::Named(fields) = struct_data.fields else {
        return Err(syn::Error::new(
            Span::call_site(),
            "database_helpers can only be used on structs with named fields",
        ));
    };

    let columns = Columns::new(&fields)?;
    Ok(columns.into_token_stream())
}

fn ident_to_upper_camel_case(ident: &syn::Ident) -> syn::Ident {
    let as_str = ident.to_string();
    let as_str = as_str.to_upper_camel_case();
    syn::Ident::new(&as_str, ident.span())
}
